/// <reference types="node" />
import { AdvancedMessageContent, Client, CommandInteraction, GuildTextableChannel, Member } from "eris";
import { EventEmitter } from "events";
import { GiveawayData, GiveawayEditOptions, GiveawayRerollOptions, GiveawaysManagerOptions, GiveawayStartOptions, PauseOptions } from "./Constants";
import { Giveaway } from "./Giveaway";
import { RichEmbed } from "./Util";
/**
 * Represents the main Giveaways manager class
 */
export declare class GiveawaysManager extends EventEmitter {
    /**
     * Eris Client
     * @type {Client}
     */
    client: Client;
    /**
     * An array of Giveaways managed by the manager
     * @type {Array<Giveaway>}
     */
    giveaways: Giveaway[];
    /**
     * The Giveaways manager options
     * @type {GiveawaysManagerOptions}
     */
    options: GiveawaysManagerOptions;
    /**
     * Whether the manager is ready or not
     * @type {Boolean}
     */
    ready: boolean;
    /**
     * Represents the main Giveaways manager class
     * @param client Eris Client
     * @param options The Giveaways manager optioons
     * @param init Whether the manager should initialize automatically
     */
    constructor(client: Client, options?: GiveawaysManagerOptions, init?: boolean);
    /**
     * Check every giveaways and update them if necessary
     * @returns {void}
     * @ignore
    */
    private _checkGiveaway;
    /**
     * Handle Discord raw gateway events
     * @param packet Discord's Gateway payload packet
     * @returns {Promise<Boolean>}
     * @ignore
     */
    private _handleRawPacket;
    /**
     * Initialize the Giveaway manager
     * @return {Promise<void>}
     * @ignore
     */
    private _init;
    /**
     * Deletes a giveaway. This will delete the giveaway's message and its data
     * @param messageID The ID of the giveaway message
     * @param doNotDeleteMessage Whether the giveaway message remains or deleted
     * @returns {Promise<Giveaway>}
     */
    delete(messageID: string, doNotDeleteMessage?: boolean): Promise<Giveaway>;
    /**
     * Deletes a giveaway from the database. See `GiveawaysManager#delete()` for client usage
     * @param messageID The ID of the giveaway message
     * @returns {Promise<any>}
     */
    deleteGiveaway(messageID: string): Promise<any>;
    edit(messageID: string, options?: GiveawayEditOptions): Promise<unknown>;
    /**
     * Edits a giveaway found in the database. See `GiveawaysManager#edit()` for client usage
     * @param messageID The ID of the giveaway message
     * @param giveawayData The giveaway data
     * @returns {Promise<any>}
     */
    editGiveaway(messageID: string, giveawayData: GiveawayData): Promise<any>;
    /**
     * Ends a giveaway. This method  will be called automatically when a giveaway supposes to end
     * @param messageID The ID of the giveaway message
     * @param noWinnerMessage Sent in the channel if there is no valid participant
     * @returns {Promise<Array<Member>>}
     */
    end(messageID: string, noWinnerMessage?: AdvancedMessageContent | string): Promise<Member[]>;
    /**
     * Generate an end embed when a giveaway has ended
     * @param giveaway The giveaway
     * @param winners An array of giveaway winners
     * @returns {RichEmbed}
     */
    generateEndEmbed(giveaway: Giveaway, winners: Member[]): RichEmbed;
    /**
     * generate an invalid embed when a giveaway has ended with not participants
     * @param giveaway The giveaway
     * @returns {RichEmbed}
     */
    generateInvalidParticipantsEndEmbed(giveaway: Giveaway): RichEmbed;
    /**
     * Generate the main embed when a giveaway is active
     * @param giveaway The giveaway
     * @param lastChanceEnabled Whether to enable the last chance mode or not. Default is `false`
     * @returns {RichEmbed}
     */
    generateMainEmbed(giveaway: Giveaway, lastChanceEnabled?: boolean): RichEmbed;
    /**
     * Gets an array of all giveaways from the database.
     * @returns {Promise<Array<GiveawayData>>}
     */
    getAllGiveaways(): Promise<GiveawayData[]>;
    /**
     * Pauses a giveaway
     * @param messageID The ID of the giveaway message
     * @param options Optional pause options
     * @returns {Promise<Giveaway>}
     */
    pause(messageID: string, options?: PauseOptions): Promise<Giveaway>;
    /**
     * Rerolls a giveaway
     * @param messageID The ID of the giveawya message
     * @param options Optional reroll options
     * @param interaction Optional Eris' command interaction
     * @returns {Promise<Array<Member>>}
     */
    reroll(messageID: string, options?: GiveawayRerollOptions, interaction?: CommandInteraction): Promise<Member[]>;
    /**
     * Saves the giveaway data in the database
     * @param messageID The ID of the giveawya message
     * @param giveawayData The giveaway data
     * @returns {Promise<any>}
     */
    saveGiveaway(messageID: string, giveawayData: GiveawayData): Promise<any>;
    /**
     * Starts a giveaway
     * @param channel The channel of the giveaway
     * @param options The start options of the giveaway
     * @returns {Promise<Giveaway>}
     */
    start(channel: GuildTextableChannel, options: GiveawayStartOptions): Promise<Giveaway>;
    /**
     * Unpauses a giveaway
     * @param messageID The ID of the giveaway message
     * @returns {Promise<Giveaway>}
     */
    unpause(messageID: string): Promise<Giveaway>;
}
